# 

# PowerDesign相关

数据库设计：

CDM：概念数据模型

PDM：物理数据模型

CDM→PDM→脚本文件（sql代码）

PowerDesigner是Sybase的企业建模和设计解决方案

PowerDesigner 一对多的关系下，cdm中，“多”的一侧不用手动设置外键，只需确定一对多的关系即可，后续物理模型建成后，会自动设置需要引用的主外键

实体由三个角度的元素组成（不用写外键）

·看得见的

·看不见的

·关联实体

某个表中的多个字段，通过关联其他实体的方式，变成一个字段

如果想实现int类型主键自增长的设置：

·对于某个物理实体，双击框架，打开，选择keys标签

·双击用户主键行，选择columns

·双击行，勾选identity

设置完成后，双击相应的物理实体框架，选择Preview标签，预览数据库语句，主键行增加“auto increment”字样

生成数据库（代码）的时候，注意Format标签内选UTF-8，否则中文注解的显示可能有障碍

·src文件夹，右键标记为源文件，才可添加软件包（package）和java类（*.java）。

·文件-项目结构-facet，增加web支持，添加web文件夹和其下web-inf文件夹

# IML不生成怎么办？

·项目所在目录，终端运行mnv idea:moudle 生成iml文件

Ctrl+左键，点击接口名，可快速跳转到实现类的展示页面（java文件）

# 0 本地数据库在项目的配置

> 复制以下内容至：main\resources\application.properties

首先在main-resources-application.properties中配置数据库，别忘了mybatis下xml文件的注册

```properties
# main\resources\application.properties

spring.datasource.url=jdbc:mysql://localhost:3306/store?useUnicode=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai
spring.datasource.username=root
spring.datasource.password=123456

mybatis.mapper-locations=classpath:mapper/*.xml

#user.address.max-count=20
#spring.servlet.multipart.max-file-size=10MB
#spring.servlet.multipart.max-request-size=15MB
```

### resources\application，修改本地数据库配置

### StoreApplication、StoreApplicationTest两个类的配置需要增加或修改，后者尤其需要重视

·前者试运行被springbootapplication注解的主函数

·后者自动装配一个datasource，再增加connection方法，试运行getconnection主类，确认连接是否可以正常加载

### 访问项目的静态资源，看是否可以正常加载：复制pages下所有资源至resources\static

### 先打开服务器：打开最底层项目名对应的项目名Application.java，运行主方法以开启本地服务器

本地服务器的默认端口在properties中修改

·static在浏览器访问时相当于根目录，也即localhost:8080（不需要另行部署tomcat）

### 创建用户的实体类

有一些公共的项目，如修改时间、创建时间，单独定义为一个base实体类（供其他类继承）

建议用包装类（Integer等）实现基础数据类型（int等）

·getter、setter、tostring、equals、hashcode

# 1 注册：持久层、业务层、控制层、前端页面开发

## 1.1 注册 持久层

通过MyBatis操作数据库。在做mybatis的开发流程。

> 持久层（Persistence Layer）是指应用程序中的一个层级，负责数据的持久化操作。持久化是指将数据存储在数据库、文件或其他持久存储介质中的过程，以便数据在应用程序结束后仍然能够被访问和使用。

> 建立mapper文件夹及其下的Mapper接口：store\mapper\UserMapper.java（声明为接口）
> 
> 在Application类中写明@MapperScan注解，指定当前项目中mapper文件夹的路径：store\StoreApplication.java
> 
> 创建xml映射文件，指定mapper标签的namespace属性为上面提到的mapper接口：store\src\main\resources\mapper\UserMapper.xml
> 
> 在xml映射文件中配置接口中的方法，注意各标签的本体及其属性完整性：store\src\main\resources\mapper\UserMapper.xml
> 
> 单元测试：test\java\com\cy\store\mapper\userMapperTests.java

### 1.1.1 规划需要执行的SQL语句

·用户的注册功能，相当于在做数据的插入操作

```sql
insert into t_user (user_name, password) values (值列表)·
```

在用户注册时，查询是否已存在用户名

```sql
select * from t_user where username=?
```

### 1.1.2 设计接口和抽象方法

定义Mapper接口。

在项目的目录结构下首先**创建一个mapper包**，在这个包下再根据不同的功能模块来创建mapper接口。

创建接口时，选择新增**java类-接口**（**绿色的**，不要选成蓝色的）

创建一个usermapper接口。要在接口中定义这两个sql语句。

输入 /**后，自动补全注释说明

```java
// store\mapper\UserMapper.java（声明为接口）

package com.cy.store.mapper;
import com.cy.store.entity.User;
import org.apache.ibatis.annotations.Mapper;

//用户模块的持久层接口
//@Mapper
public interface UserMapper {
    /**
     * 插入用户的数据
     * @param user 用户的数据
     * @return 受影响的行数（在增删改都有受影响行数作为返回值，可以根据返回值判断是否执行成功）
     */
    Integer insert(User user);

    /**
     * 根据用户名，查询用户的数据
     * @param username 用户名
     * @return 如果找到对应的用户则返回这个用户的数据，否则返回null值
     */
    User findByUsername(String username);
}
```

在StoreApplication.java中，设置@MapperScan("com.cy.store.mapper")注解，指定当前项目中Mapper路径的位置

```java
// store\StoreApplication.java

@SpringBootApplication
//MapperScan注解，指定当前项目中Mapper路径的位置。在项目启动时，会自动加载所有的接口文件
@MapperScan("com.cy.store.mapper")

// 下跟其他内容
```

### 1.1.3 编写映射（与接口同名的xml文件）

#### 1.1.3.1 定义xml映射文件，与对应的接口进行关联。

所有的映射文件需要放置在resources目录下，在这个目录下创建一个mapper文件夹，在这个文件夹下存放mapper的映射文件。

#### 1.1.3.2 创建接口所对应的映射文件，遵循和接口的名称保持一致即可。

创建一个UserMapper.xml的文件（下面一段是开头）。其中，**mapper标签内namespace的内容需指定在实际的接口**。后续编写sql语句时,需要在mapper标签内增加内容。

```xml
<!-- store\src\main\resources\mapper\UserMapper.xml -->

<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!-- namespace属性：用于指定当前的映射文件和哪个接口进行映射，所以需要指定接口的文件路径，故需标注包的完整结构-->
<mapper namespace="com.cy.store.mapper.UserMapper">
</mapper>
```

#### 1.1.3.3 在xml映射文件中配置接口中的方法，对应SQL语句

需要借助标签完成。提供了insert、update、delete、select等四个标签。

```xml
<!--UserMapper.xml，与接口同名-->

<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!-- namespace属性：用于指定当前的映射文件和哪个接口进行映射，所以需要指定接口的文件路径，故需标注包的完整结构-->
<mapper namespace="com.cy.store.mapper.UserMapper">

    <!--自定义映射规则：resultMap标签来完成映射规则的定义
        id属性：给这个映射规则分配一个唯一的id值，对应的就是resultMap="id属性的值"属性的取值
        type属性：取值是一个类，表示的是数据库中的查询结果与Java中哪个实体类进行结果集的映射
    -->
    <resultMap id="UserEntityMap" type="com.cy.store.entity.User">
        <!--将表的字段和类的属性 不一致 的字段进行匹配指定，一致的则可以省略不写-->
        <!--column属性：表中字段名 property属性：类中属性名 两者配合完成名称不一致的映射-->
        <!--定义映射规则时，主键不允许省略！-->
        <id column="uid" property="uid"></id>
        <result column="is_delete" property="isDelete"></result>
        <result column="created_user" property="createdUser"></result>
        <result column="created_time" property="createdTime"></result>
        <result column="modified_user" property="modifiedUser"></result>
        <result column="modified_time" property="modifiedTime"></result>
    </resultMap>

    <!-- id表示映射接口中方法名称，直接在标签内部编写sql语句-->
    <!-- uid是主键，sql语言设定为自增（AUTO_INCREMENT），不写在下面的语句中 -->
    <!--
        useGeneratedKeys属性：表示开启某个字段（一般是主键）值的递增
        keyProperty属性：设为递增的字段对应的【实体类的属性名】
    -->
    <insert id="insert" useGeneratedKeys="true" keyProperty="uid">
        INSERT INTO t_user (
        username, password, salt, phone, email,
        gender, avatar, is_delete,
        created_user, created_time,
        modified_user, modified_time
        ) VALUES (
        <!--下面的值是前端传过来的实例值，因此需要改成驼峰命名法
        mybatis要求用 #{} 对变量占位-->
        #{username} , #{password}, #{salt}, #{phone}, #{email},
        #{gender}, #{avatar}, #{isDelete},
        #{createdUser}, #{createdTime},
        #{modifiedUser}, #{modifiedTime}
        )
    </insert>

    <!--select语句执行的时候，查询的是一个对象或多个对象
        resultType：用于表示查询的结果集类型，需要指定对应映射的类的类型，并且包含完整的包结构
        resultMap：当表的字段和属性字段一致时无碍，若不一致则需要自定义查询结果集的映射规则
    -->
    <select id="findByUsername" resultMap="UserEntityMap">
        SELECT * from t_user WHERE username = #{username}
    </select>
</mapper>
```

#### 1.1.3.4 单元测试

每个独立的层编写完毕后，需要编写单元测试方法，来测试当前的功能。这样可以尽量缩小异常代码范围。

在test包结构下，创建一个mapper包，在这个包下再创建持久层的功能测试。

为UserMapperTests.java添加必要的注解：@SpringBootTest、@RunWith。

声明一个接口，在接口上添加@Autowired自动装配注解。

```java
// test\java\com\cy\store\mapper\userMapperTests.java

package com.cy.store.mapper;

import com.cy.store.entity.User;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

//@SpringBootTest注解 表示标注当前的类是一个测试类，不会随同项目一起打包发送
@SpringBootTest
//@RunWith注解 表示启动这个单元测试类。
@RunWith(SpringRunner.class)
public class UserMapperTests {
    //老版本的idea有检测功能，接口是不能够直接创建Bean的（动态代理技术来解决）
    //没报错就不用管
    //报错了就idea-设置-编辑器-检查-Spring-Spring Core-代码
    //-Spring Bean组件中不正确的自动装配，严重性改为警告
    @Autowired
    private UserMapper userMapper;
    /**
     * 单元测试方法要想单独独立运行（不用启动整个项目即可进行单元测试），必须同时满足的特点如下：
     * 1 必须被Test注解所修饰
     * 2 返回值类型必须是void
     * 3 方法的参数列表不能指定任何类型
     * 4 方法的访问修饰符必须是public
     */
    @Test
    public void insert() {
        User user = new User();
        user.setUsername("Tim");
        user.setPassword("123");
        Integer rows = userMapper.insert(user);
        System.out.println(rows);
    }

    @Test
    public void findByUsername() {
        User user = userMapper.findByUsername("tim");
        System.out.println(user);
    }
}
```

检查application.properties内是否添加了

```properties
mybatis.mapper-locations=classpath:mapper/*.xml
```

## 1.2  注册 业务层

### 1.2.1 规划异常

> 建立类：store\service\ex\ServiceException.java 继承RuntimeException
> 
> 建立类：store\service\ex\UsernameDuplicatedException.java
> 
> 建立类：store\service\ex\UsernameDuplicatedException.java

RuntimeException异常，作为←异常的子类，然后去定义具体的异常类型来继承，避免异常过于笼统。

定义业务层异常的基类为ServiceException，这个异常继承RuntimeException异常。

如此，一套异常机制被建立起来了。

> **service包下，放的是业务层的功能代码。**
> 
> service下，建立ex和impl等两个软件包。
> 
> 如果有接口，直接放在service下即可，不需再往次级文件夹内储存。

```java
//service\ex\ServiceException.java

package com.cy.store.service.ex;

/* 作为业务层异常的基类：throws new ServiceException(根据需要修改参数或保持无参)
 * 由于业务层的所有异常都在运行时产生，所以都继承RuntimeException。
*/
public class ServiceException extends RuntimeException{
    //借用右键快捷方式【生成-重写】，选中父类RuntimeException的全部5个，定义构造方法

    public ServiceException() {
        super();
    }

    public ServiceException(String message) {
        super(message);
    }

    public ServiceException(String message, Throwable cause) {
        super(message, cause);
    }

    public ServiceException(Throwable cause) {
        super(cause);
    }

    protected ServiceException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}
```

根据业务层不同的业务功能，详细地定义具体的异常类型，之后让它们统一继承ServiceException异常类。

2 注册用户时，可能用户名被占用。此时抛出异常：UsernameDuplicatedException。

```java
// store\service\ex\UsernameDuplicatedException.java

package com.cy.store.service.ex;

//用户名被占用的异常
public class UsernameDuplicatedException extends ServiceException{
    public UsernameDuplicatedException() {
        super();
    }

    public UsernameDuplicatedException(String message) {
        super(message);
    }

    public UsernameDuplicatedException(String message, Throwable cause) {
        super(message, cause);
    }

    public UsernameDuplicatedException(Throwable cause) {
        super(cause);
    }

    protected UsernameDuplicatedException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}
```

3 正在执行数据插入操作的时候，服务器or数据库宕机。处于正在执行插入的过程中所产生的异常，命名为InsertException。

```java
// store\service\ex\InsertException.java

package com.cy.store.service.ex;

//表示数据在插入过程中（服务器or数据库宕机）所产生的异常
public class InsertException extends ServiceException{
    public InsertException() {
        super();
    }

    public InsertException(String message) {
        super(message);
    }

    public InsertException(String message, Throwable cause) {
        super(message, cause);
    }

    public InsertException(Throwable cause) {
        super(cause);
    }

    protected InsertException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}
```

### 1.2.2 设计接口和抽象方法的定义

> 建立业务层的接口：store\service\IuserService.java
> 
> 建立实现类：store\service\impl\UserServiceImpl.java
> 
> 建立单元测试类：test\java\com\cy\store\service\UserServiceTest.java

1 在service包下，创建一个接口。建议采用大写I开头，再跟上业务名称。如果是业务层的，再跟上业务名。例如：IUserService。

```java
// store\service\IuserService.java（声明为接口interface而非类class）

package com.cy.store.service;

import com.cy.store.entity.User;

//用户模块业务层接口
public interface IUserService {
    /**
     * 用户注册方法
     * @param user 用户的数据对象
     */
    void reg(User user);
}
```

2 创建一个实现类，命名为UserServiceImpl，需要实现这个接口，并且实现抽象的方法。

    在实现类中，右键【重写-实现方法】，快速生成

    补充其他必要的注解等（如本类需用Service注解）

    在reg方法体外，再写一个返回加密后密码的方法

```java
// store\service\impl\UserServiceImpl.java

package com.cy.store.service.impl;

import com.cy.store.entity.User;
import com.cy.store.mapper.UserMapper;
import com.cy.store.service.IUserService;
import com.cy.store.service.ex.InsertException;
import com.cy.store.service.ex.UsernameDuplicatedException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.DigestUtils;

import java.util.Date;
import java.util.UUID;

//用户模块业务层的实现类
@Service //不加就报错：依赖异常。该注解起到将当前类的对象交给Spring管理的作用，自动创建对象、维护对象。
public class UserServiceImpl implements IUserService {
    @Autowired
    private UserMapper userMapper;
    @Override
    public void reg(User user) {
        //通过user参数获取传递过来的username
        String username = user.getUsername();
        //调用userMapper的findByUsername，检查是否已存在同名用户
        User result = userMapper.findByUsername(username);
        //判断结果集是否为null。如果不为null，则抛出用户名被占用的异常。
        if (result != null) {
            //抛出异常
            throw new UsernameDuplicatedException("用户名被占用");
        }

        //密码的加密处理：md5算法的形式
        //串 + 真实password + 串 ---- 交给md5算法进行加密，连续加载三次
        //串是谁？是盐值。盐值 + password + 盐值 ---- 盐值就是一个随机的字符串
        String oldPassword = user.getPassword();
        //获取盐值（随机生成一个 全大写的 盐值字符串）
        String salt = UUID.randomUUID().toString().toUpperCase();
        //记录盐值，补全对应字段
        user.setSalt(salt);
        //将密码和盐值作为一个整体进行加密处理
        //忽略原密码的强度，提升了数据的安全性
        String md5Password = getMD5Password(oldPassword, salt);
        //将加密之后的密码重新补全设置到user对象中去
        user.setPassword(md5Password);

        //在insert之前，补全其他必要的属性：is_delete=0，4个日志字段
        user.setIsDelete(0);
        user.setCreatedUser(user.getUsername());
        user.setModifiedUser(user.getUsername());
        Date date = new Date();
        user.setCreatedTime(date);
        user.setModifiedTime(date);

        //若无异常，执行 注册 业务逻辑
        Integer rows = userMapper.insert(user);

        //如果执行成功，返回值为1，否则抛出异常
        if(rows != 1) {
            throw new InsertException("在用户注册过程中，产生了未知的异常");
        }
    }

    //定义一个md5算法的加密处理方法
    private String getMD5Password(String password, String salt) {
        //md5加密算法的调用（进行三次加密）
        for (int i=0; i<3; i++) {
        password = DigestUtils.md5DigestAsHex((salt+password+salt).getBytes()).toUpperCase();
        }
        //返回加密之后的密码
        return password;
    }
}
```

3 在单元测试包下，创建一个UserServiceTests类，在这个类中，添加单元测试的功能。

```java
// test\java\com\cy\store\service\UserServiceTest.java

package com.cy.store.service;

import com.cy.store.entity.User;
import com.cy.store.mapper.UserMapper;
import com.cy.store.service.ex.ServiceException;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

//@SpringBootTest注解 表示标注当前的类是一个测试类，不会随同项目一起打包发送
@SpringBootTest
//@RunWith注解 表示启动这个单元测试类。
@RunWith(SpringRunner.class)
public class UserServiceTests {
    //老版本的idea有检测功能，接口是不能够直接创建Bean的（动态代理技术来解决）
    //没报错就不用管
    @Autowired
    private IUserService iUserService;
    /**
     * 单元测试方法要想单独独立运行（不用启动整个项目即可进行单元测试），必须同时满足的特点如下：
     * 1 必须被Test注解所修饰
     * 2 返回值类型必须是void
     * 3 方法的参数列表不能指定任何类型
     * 4 方法的访问修饰符必须是public
     */
    @Test
    public void reg() {
        try {
            User user = new User();
            user.setUsername("yuanxin01");
            user.setPassword("123");
            iUserService.reg(user);
            System.out.println("插入成功");
        } catch (ServiceException e) {
            //先获取类的对象，再获取类的名称
            System.out.println(e.getClass().getSimpleName());
            //获取异常的具体描述信息（先前自定义了被抛出时打印的内容）
            System.out.println(e.getMessage());
        }
    }
}
```

## 1.3 注册 控制层

### 1.3.1 创建响应

响应分为：状态码、状态描述信息、数据。

上述功能封装在一个类中，将这个类作为方法的返回值，返回给前端浏览器。

> 建立用于构建可供返回前端显示的Json字符串内部结构的JsonResult.java响应类：\store\util\JsonResult.java

```java
// store\util\JsonResult.java

package com.cy.store.util;

import java.io.Serializable;

/**
 * Json格式的数据进行响应。<E>声明泛型。
 */
public class JsonResult<E> implements Serializable {
    //状态码
    private Integer state;
    //描述信息
    private String message;
    //对应的数据（用泛型表示）
    private E data;

    public JsonResult() {

    }

    public JsonResult(Integer state) {
        this.state = state;
    }

    public JsonResult(Throwable e) {
        this.message = e.getMessage();
    }

    public JsonResult(Integer state, E data) {
        this.state = state;
        this.data = data;
    }

    public Integer getState() {
        return state;
    }

    public void setState(Integer state) {
        this.state = state;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public E getData() {
        return data;
    }

    public void setData(E data) {
        this.data = data;
    }
}
```

### 1.3.2 设计请求

依据当前的业务功能模块进行请求的设计。

> 请求的路径：/users/reg
> 
> 请求的参数：User user
> 
> 请求类型：POST
> 
> 响应结果：JsonResult<Void>

### 1.3.3 处理请求

> 建立类：\store\controller\UserController.java
> 
> 建立类：\store\controller\BaseController.java

1 创建一个控制层对应的类：UserController类。此类依赖于业务层的接口。

2 创建一个BaseController类，编写统一处理异常的方法，受UserController类继承。

```java
// store\controller\UserController.java

package com.cy.store.controller;

import com.cy.store.entity.User;
import com.cy.store.service.IUserService;
import com.cy.store.service.ex.InsertException;
import com.cy.store.service.ex.UsernameDuplicatedException;
import com.cy.store.util.JsonResult;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

//@Controller
@RestController //等效于@Controller + @ResponseBody
@RequestMapping("users")
public class UserController extends BaseController{
    @Autowired
    private IUserService userService;

    @RequestMapping("reg")
    public JsonResult<Void> reg(User user) {
        userService.reg(user);
        return new JsonResult<>(OK);
    };
}
```

```java
// store\controller\BaseController.java

package com.cy.store.controller;

import com.cy.store.service.ex.InsertException;
import com.cy.store.service.ex.ServiceException;
import com.cy.store.service.ex.UsernameDuplicatedException;
import com.cy.store.util.JsonResult;
import org.springframework.web.bind.annotation.ExceptionHandler;

//表示控制层类的基类
public class BaseController {
    //声明一个状态码OK常量，表示操作成功。
    public static final int OK = 200;

    //如果操作不成功，需要建立一个方法，用于统一处理。
    //请求处理方法，这个方法的返回值就是需要传递给前端的数据。
    //自动将异常对象传递给此方法的参数列表上
    //当项目中产生了异常，会被统一拦截到此方法中，这个方法此时就充当了请求处理方法，方法的返回值直接给到前端。
    @ExceptionHandler(ServiceException.class) //该注解用于统一处理抛出的异常
    public JsonResult<Void> handleException(Throwable e) {
        JsonResult<Void> result = new JsonResult<>(e);
        if (e instanceof UsernameDuplicatedException) {
            result.setState(4000);
            result.setMessage("用户名已经被占用");
        }
        else if (e instanceof InsertException) {
            result.setState(5000);
            result.setMessage("注册时产生未知的异常");
        }
        return result;
    }
}
```

### 1.3.4 控制层优化设计

在控制层抽离出来一个父类，在这个父类中，统一处理关于异常的相关内容及其操作。

编写一个名叫BaseController的类。在这个类里，借用@ExceptionHandler注解统一处理异常。

代码详见上面C.3节中的两段。

## 1.4 注册 前端页面

> 找到register.html，将设计好的请求格式补写至内部ajax函数

1 在register.html页面中，编写发送请求的方法，借助点击事件完成。选中对应的按钮（$("选择器))，再去添加点击的事件。

$.ajax函数发送异步请求。（实现局部加载）

2 JQuery封装了一个函数，称为$.ajax()函数，通过对象调用ajax函数，可以异步加载相关的请求。依靠的是封装了JavaScript提供的一个对象XHR（XmlHttpResponse）。

3 ajax()的使用方式：需要传递一个方法体作为参数来使用。一对大括号称之为方法体。ajax接受多个参数，参数之间使用半角英文逗号进行分割，每个参数的名与值之间通过冒号分割。参数的组成部分一个是参数的名称（不能随意定义），一个是参数的值（要求使用双引号引起来的字符串来表示）。参数的声明顺序没有要求。

语法结构：

```
$.ajax({
    url: "",
    type: "",
    data: "",
    dataType: "",
    success: function() {

    },
    error: function() {

    }
});
```

4 ajax函数参数的含义

| 参数       | 功能描述                                                         |
|:--------:| ------------------------------------------------------------ |
| url      | 标识请求地址。不能包含参数列表部分的内容。例如：url: "localhost:8080/users/reg"      |
| type     | 请求类型（GET、POST）。例如：type:"POST"                                |
| data     | 向指定的请求url地址提交的数据。例如：data: "username=tom&pwd=123"             |
| dataType | 提交的数据的类型。数据的类型一般指定为json。例如：dataType: "json"                  |
| success  | 当服务器正常响应客户端时，会自动调用success参数的方法，并且将服务器返回的数据以参数的形式传递给这个方法的参数上。 |
| error    | 当服务器未正常响应客户端时，会自动调用error参数的方法，并且将服务器返回的数据以参数的形式传递给这个方法的参数上。  |

5 js代码可以独立声明在一个后缀为js的文件里，或者声明在一个script标签中。示例代码段采用后者，嵌入到register.html中。

```js
<script type="text/javascript">
            //1. 监听注册按钮是否被点击。如果被点击，可以执行一个方法
            $("#btn-reg").click(function() {
                //动态获取表单中控制的数据
                console.log($("#form-reg").serialize());
                //2. 发送ajax的异步请求来完成用户的注册功能
                $.ajax({
                    url: "/users/reg", //省略直至端口号的部分
                    type: "POST",
                    // 自动改写成右边的形态：username=Tom&password=123
                    data: $("#form-reg").serialize(),
                    dataType: "json",
                    success: function (json) { //js是弱数据类型，不必提前声明数据类型
                        if(json.state == 200) {
                            alert("注册成功！");
                        } else {
                            alert("注册失败！");
                        }
                    },
                    error: function (xhr) {
                        alert("注册时，产生了未知的错误！错误代码为 "+" "+xhr.status);
                    }
                });
            });
        </script>
```

6 js代码无法正常被服务器解析执行，主要体现在点击页面中的按钮没有任何响应。这时，可以通过①clean、install maven项目、②文件-清除缓存、③重新构建项目 等方式解决。

# 2 登录：持久层、业务层、控制层、前端页面

用户输入用户名、密码→数据提交给后台数据库进行查询→若存在对应记录，则表示登录成功；登陆成功之后即跳转至系统主页（index.html）。跳转功能在前端使用jquery完成。

## 2.1 登录 持久层

### 2.1.1 规划需要执行的SQL语句

依据用户提交的用户名和密码作select查询。

密码的比较放在业务层执行。

```sql
select username from t_user where username=?
```

**注意！** 如果在分析过程中发现某个功能模块已经被开发完成，即省略相应的实际步骤（但分析的过程不能省略）（UserMapper.xml映射文件中已经预留了一个方法，所以没必要重新编写sql语句了）。

### 2.1.2 接口设计和方法

不用重复开发。单元测试同样无需单独执行。

## 2.2 登录 业务层

### 2.2.1 规划异常

1 用户名对应的密码错误，密码匹配失败的异常：PasswordNotMatchException（这是一个运行时异常，也是一个业务异常，所以只需继承业务异常）

2 用户名不存在：抛出异常UserNotFoundException（这是一个业务异常）

3 异常的编写分为两步：

    Step1 需要继承ServiceException业务异常类；

    Step2 在具体的异常类中通过右键生成5个构造方法（实际上通过复制粘贴其他结构完全相似的类，内部方法名会自动重构，无需再行手动调整）。

### 2.2.2 设计接口和抽象方法

> 在\store\service下找到IUserService.java，补写login抽象方法
> 
> 建立实现类：\store\service\impl\UserServiceImpl.java
> 
> 测试业务层的login接口：test\java\java\com\cy\store\service\StoreApplicationTest.java

1 直接在IUserService接口中，编写**抽象方法**login(String username, String password)。为了便于展示当前登录的用户，将当前登录成功的用户数据以当前用户对象的形式进行返回。

状态管理：可以将数据保存在cookie或session中，可以避免重复度很高的数据频繁操作数据进行获取（用户名、用户id：存放在session中，用户头像保存在位于客户端的cookie中）。

2 需要在实现类中实现父接口中的抽象方法。

```java
// store\service\impl\UserServiceImpl.java

@Override
    public User login(String username, String password) {

        // 根据用户名称来查询用户的数据是否存在。若不存在，则抛异常。
        // 调用userMapper的findByUsername方法
        User result = userMapper.findByUsername(username);
        if (result == null) {
            throw new UserNotFoundException("用户数据不存在");
        }

        // 检测用户的密码是否匹配
        //1. 先获取到数据库中的加密后的密码
        String encryptedPassword = result.getPassword();
        //2. 和用户传递过来的密码进行比较（不能直接比）
        //2.1 获取注册时自动生成的盐值
        String salt = result.getSalt();
        //2.2 将用户的密码按照相同的md5算法规则进行加密
        String newMD5Password = getMD5Password(password, salt);
        //3. 将密码进行比较
        if (! newMD5Password.equals(encryptedPassword)) {
            throw new PasswordNotMatchException("用户密码错误");
        }

        // 判断用户是否已注销账号（数据库表中is_delete的值是否为1）
        if (result.getIsDelete() == 1) {
            throw new UserNotFoundException("用户数据不存在");
        }

        // 无异常，调用mapper层的findByUsername方法，对用户数据记录执行查询
        // User user = userMapper.findByUsername(username);
        // 不用调取记录所有的字段，轻量化数据，提高传输效率和响应速度，提升了系统性能
        User limitedUser = new User();
        limitedUser.setUid(result.getUid());
        limitedUser.setUsername(result.getUsername());
        limitedUser.setAvatar(result.getAvatar());

        // 返回用户数据。
        // 发现返回的数据是为了辅助其他页面作数据展示使用（只涉及uid、username和avatar）
        //
        return limitedUser;
    }
```

3 在测试类中测试业务层登录的方法是否可以执行通过。

```java
// test\java\java\com\cy\store\service\StoreApplicationTest.java

@Test
    public void login() {
        try {
            User limitedUser =
                    iUserService.login("test001", "123");
            System.out.println(limitedUser);
        } catch (ServiceException e) {
            //throw new RuntimeException(e);
            //先获取类的对象，再获取类的名称
            System.out.println(e.getClass().getSimpleName());
            //获取异常的具体描述信息（先前自定义了被抛出时打印的内容）
            System.out.println(e.getMessage());
        }
    }
```

    如果一个类没有手动创建而是复制到项目中的，idea就找不到这个类（没出现不用管，出现就重构一下项目）。

## 2.3 登录 控制层

### 2.3.1 处理异常

> 在异常处理基类，补写登录异常：\store\controller\BaseController.java

业务层抛出的异常是什么？

需要在统一异常处理类**BaseController**中进行统一的捕获和处理吗？

如果业务层抛出的异常类型已经存在于统一的异常处理类中，则无需重复添加。

```java
else if (e instanceof UserNotFoundException) {
            result.setState(5001);
            result.setMessage("用户数据不存在的异常");
        } else if (e instanceof PasswordNotMatchException) {
            result.setState(5002);
            result.setMessage("用户名对应密码错误的异常");
        }
```

### 2.3.2 设计请求

1 请求路径：/users/login

2 请求方式：POST

3 请求数据：String username, String password, HttpSession session

4 响应结果：JsonResult<User>

### 2.3.3 处理请求

> 补写控制层实现login()的方法：store\controller\UserController.java

在UserController类中编写处理请求的方法。

```java
// store\\controller\UserController.java
// 此处已添加session的绑定，参考2.4节

@RequestMapping("login")
    public JsonResult<User> login(String username, 
                                    String password,
                                    HttpSession session) {
        User limitedUser = userService.login(username, password);
        return new JsonResult<User>(OK, limitedUser);
    }
```

## 2.4 登录 前端页面

> 找到login.html，补写ajax

1 在login.html页面中依据前面所设计的请求来发送ajax请求。

```js
<script type="text/javascript">
            //启动对btn-login按钮的监听
            $("#btn-login").click(function () {
                $.ajax({
                    url: "/users/login",
                    type: "POST",
                    //表单数据的序列化
                    data: $("#form-login").serialize(),
                    dataType: "JSON",
                    success: function (json) {
                        if (json.state == 200) {
                            alert("登录成功！");
                            // 跳转到主页index.html
                            // 相对路径来确定跳转的页面。
                            // 同级可加./也可不加；上级则需加../
                            location.href = "./index.html";
                        } else {
                            alert("登录失败！");
                        }
                    },
                    error: function (xhr) {
                        alert("登录时产生未知的异常。错误信息：" + xhr.message);
                    }
                });
            });
        </script>
```

2 访问页面，进行用户的登录操作。

## 2.5 用户会话session的保存

> 在异常处理基类中定义从Session获取uid和username的方法：store\controller\BaseController.java
> 
> 在控制层将登录后的uid和username更新至session的内容：store\controller\UserController.java

session对象主要存储在服务器端，是一个可以用于保存服务器的临时数据的对象。所保存的数据，可以在整个项目中通过访问来获取。

可以把seesion的数据看作一个共享的数据。

在首次登录的时候所获取到的用户数据，转移到session对象中即可。

session.getArrtibute("key")

↑ 可以将获取session中的数据这种行为进行封装，封装在BaseController类中。

1 封装session对象中数据的获取（封装在父类中）、数据的设置（当用户登录成功后，进行数据的设置。设置到全局的session对象中）。

2 在父类中封装两个数据：①获取uid和获取username对应的两个方法。用户头像因为要封装在cookie中，所以暂时不考虑。

```java
// store\controller\BaseController.java
    /**
     * 获取session对象中的uid
     * @param session session对象
     * @return 当前登录用户的uid值
     */
    protected final Integer getUidFromSession(HttpSession session) {
        return Integer.valueOf(session.getAttribute("uid").toString());
    }

    /**
     * 获取当前登录用户的username
     * @param session session对象
     * @return 当前登录用户的用户名
     * 在实现类中，重写父类中的toString()，不是句柄信息的输出
     */
    protected final String getUsernameFromSession(HttpSession session) {
        return session.getAttribute("username").toString();
    }
```

3 在登录的方法中，将数据封装在session对象中。

服务器启动后，本身已创建了全局的session对象。

SpringBoot直接使用session对象，直接将HttpSession类型的对象作为请求处理方法的参数。即使自行new 一个HttpSession对象，也会被注入。【这里返回2.3.2 设计请求，增加一项请求数据：HttpSession session】

```java
// UserController.java 更新登录控制层

@RequestMapping("login")
    public JsonResult<User> login(String username, String password,
                                  HttpSession session) {
        User limitedUser = userService.login(username, password);
        // 向session对象中完成数据的绑定（session是全局的）
        session.setAttribute("uid", limitedUser.getUid());
        session.setAttribute("username", limitedUser.getUsername());

        // 测验：获取session中绑定的数据
        // 在终端输出
        //System.out.println(getUidFromSession(session));
        //System.out.println(getUsernameFromSession(session));

        return new JsonResult<User>(OK, limitedUser);
    }
```

## 2.6 拦截器

> 建立类：store\interceptor\LoginInterceptor.java
> 
> 建立类：store\config\LoginInterceptorConfigurer.java

拦截器：首先将所有的请求统一拦截到拦截器中，可以在拦截器中定义过滤的规则。如果不满足系统设置的过滤规则，统一的处理是重新去打开login.html（强制先登录再用更深入的功能）（重定向or转发），推荐使用重定向功能。（转发在服务器内部完成，若其他功能部署在其他服务器上就不能用了，所以推荐用重定向）

在SpringBoot项目中，拦截器的定义和使用是依靠SpringMVC来完成的。SpringMVC提供了一个接口HandlerInterceptor，用于定义一个拦截器。首先，自定义一个类，再让这个类实现这个接口。

1 自定义一个类，让这个类实现HandlerInterceptor接口。在store下创建一个interceptor软件包，接着在下面创建一个类LoginInterceptor.

    HandlerInterceptor接口有三个方法，preHandle()、postHandle()、afterCompletion()。①preHandle()方法在所有处理请求的方法之前即被自动调用执行；②postHandle()方法在ModelAndView对象返回之后被调用；③afterCompletion()方法在整个请求所有关联的资源均被执行完毕，最后执行的方法。

```java
// store\interceptor\LoginInterceptor.java

package com.cy.store.interceptor;

import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * 定义一个拦截器
 */
public class LoginInterceptor implements HandlerInterceptor {

    /**
     * 检测全局session对象中是否有uid数据，若有则放行，若无则重定向至登录页
     * @param request 请求对象
     * @param response 响应对象
     * @param handler 处理器（url+Controller：映射）
     * @return 若返回true表示放行当前的请求，否则表示拦截当前请求
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request,
                             HttpServletResponse response,
                             Object handler) throws Exception {
        // HttpServletRequest对象来获取session对象
        Object obj = request.getSession().getAttribute("uid");
        if (obj == null) {
            // 说明用户未登录，重定向至index.html
            // 参数是localhost:8080/后的浏览器中实际url
            response.sendRedirect("/web/login.html");
            // 结束后续的调用
            return false;
        }
        // 当前请求被放行
        return true;
    }
}
```

2 注册拦截器：添加白名单（不登录可访问的资源：login.html register.html index.html product.html users/reg users/login）、添加黑名单（登录才能访问的资源）。

3 注册拦截器的技术：结束WebMvcConfigure接口，可以将用户定义的拦截器进行注册，才可以保证拦截器能够生效和使用。定义一个类，然后让这个类实现WebMvcConfigure接口。配置信息建议存放在项目的Config包结构下。

    在store目录下建立config包，其下再建立LoginInterceptorConfigurer类。

    addInterceptors()方法的作用是注册自定义拦截器

```java
// store\config\LoginInterceptorConfigurer.java

package com.cy.store.config;

import com.cy.store.interceptor.LoginInterceptor;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import java.util.ArrayList;
import java.util.List;

/**
 * 处理器拦截器的注册
 */
@Configuration // 加载当前的拦截器并进行注册
public class LoginInterceptorConfigurer implements WebMvcConfigurer {
    /**
     * 配置拦截器
     * @param registry
     */
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 创建自定义的拦截器对象
        HandlerInterceptor interceptor = new LoginInterceptor();

        // 配置白名单：存放在一个List集合中
        List<String> patterns = new ArrayList<String>();
        patterns.add("/bootstrap3/**");
        patterns.add("/css/**");
        patterns.add("/images/**");
        patterns.add("/js/**");
        patterns.add("/web/register.html");
        patterns.add("/web/login.html");
        patterns.add("/web/index.html");
        patterns.add("/web/product.html");
        patterns.add("/users/reg");
        patterns.add("/users/login");

        // 完成拦截器的注册
        // addPathPatterns表示要拦截的url是什么，/**表示拦截这一级以下的全部
        // excludePathPatterns接收List集合作为参数
        registry.addInterceptor(interceptor)
                .addPathPatterns("/**")
                .excludePathPatterns(patterns);
    }
}
```

4 浏览器可能会提示重定向次数过多，导致白名单（含login）页面都打不开了。如何解决？将浏览器的cookie清除，再将浏览器设置为初始设置。

# 3 修改密码

需要用户提交原始密码和新密码，再根据当前登录的用户进行信息的修改操作。

## 3.1 修改密码：持久层

### 3.1.1 规划需要执行的SQL语句

根据用户的uid，修改用户的password值。

```sql
update t_user set password=? modified_? modified_time=? where uid=?
```

根据uid查询用户的数据：

    在修改密码之前，首先要保证当前这个用户的数据存在，检测是否被标记为已删除。

    也要检测输入的原始密码是否正确。

```sql
select * from t_user where uid=?
```

### 3.1.2 设计接口和抽象方法

还是用UserMapper接口，将以上的两个方法的抽象给定义出来，将来映射到两条sql语句上。

注意：多参数传入时，在接口中声明抽象方法的时候，用注解绑定参数名，以免无法通过测试。

```java
/**
     * 增删改都会返回一个影响的行数，所以用Integer作返回类型
     * 根据用户的Uid修改用户的密码
     * @param uid 用户的id
     * @param password 用户输入的新密码
     * @param modifiedTime 修改的执行者
     * @param modifiedUser 修改的时间
     * @return 返回值为受影响的行数
     */
    // 多参数传入，用注解@Param绑定，避免错误
    Integer updatePasswordByUid(@Param("uid") Integer uid,
                                @Param("password") String password,
                                @Param("modifiedUser") String modifiedUser,
                                @Param("modifiedTime") Date modifiedTime);

    /**
     * 根据用户的id查询用户的数据
     * @param uid 用户的id
     * @return 如果找到了，返回一个对象，反之返回一个null值
     */
    User findByUid(Integer uid);
```

### 3.1.3 sql映射的配置

将以上两个方法配置到映射文件UserMapper.xml中。

```sql
<update id="updatePasswordByUid">
        UPDATE T_USER SET
            password=#{password},
            modified_user=#{modifiedUser},
            modified_time=#{modifiedTime}
        WHERE uid=#{uid}
    </update>

    <select id="findByUid" resultMap="UserEntityMap">
        SELECT * FROM t_user WHERE uid=#{uid}
    </select>
```

### 3.1.4 单元功能测试

```java
@Test
    // 单元测试方法 不能有参数列表
    public void updatePasswordByUid() {
        Integer rows = userMapper.updatePasswordByUid(
                7, "321",
                "管理员", new Date());
        System.out.println("受影响的行数为：" + rows);
    }

    @Test
    public void findByUid() {
        User user = userMapper.findByUid(7);
        System.out.println(user);
    }
```

## 3.2 修改密码：业务层

### 3.2.1 规划异常

1 用户的源密码错误 is_delete==1 uid找不到，在用户没有发现的异常

2 update 在更新的时候，可能产生未知的异常，命名为UpdateException。

### 3.2.2 设计接口和抽象方法

在IUserService接口中，写出执行用户修改密码的核心方法。

```java
void changePassword(Integer uid,
                        String username,
                        String oldPassword,
                        String newPassword);
```

在UserServiceImpl实现类中，重写对应的抽象方法。

```java
@Override
    public void changePassword(Integer uid, String username,
                               String oldPassword, String newPassword) {
        User result = userMapper.findByUid(uid);
        if (result == null || result.getIsDelete() == 1) {
            throw new UserNotFoundException("用户数据不存在");
        }
        // 原始密码和数据库中的密码进行比较
        String oldMD5Password =
                getMD5Password(oldPassword, result.getSalt());
        if (! result.getPassword().equals(oldMD5Password)) {
            throw new PasswordNotMatchException("密码错误");
        }
        // 将新的密码设置到数据库中：将新的密码进行加密后，再进行更新。
        String newMD5Password =
                getMD5Password(newPassword, result.getSalt());
        Integer rows =
                userMapper.updatePasswordByUid(uid, newMD5Password,
                                        username, new Date());
        if (rows != 1) {
            throw new UpdateException("更新数据时，产生未知的异常");
        }
    }
```

在单元测试类中，编写测试方法。

（代码省略）

## 3.3 修改密码：控制层

业务层有没有异常？有就在控制层处理，否则就过。

### 3.3.1 处理异常

引入了一个新的异常UpdateException，需要配置在统一的异常处理方法（BaseController）中。

```java
else if (e instanceof UpdateException) {
              result.setState(5003);
              result.setMessage("更新数据时产生未知的异常");
        }
```

### 3.3.2 设计请求

> 请求路径：users/change_password
> 
> 请求方式：post
> 
> 从前端接收：String oldPassword, String newPassword（需要和表单中的name属性一致）
> 
> 响应：不需要返回前端，JsonResult

### 3.3.3 处理请求

```java
@RequestMapping("change_password")
    public JsonResult<Void> changePassword(String oldPassword,
                                           String newPassword,
                                           HttpSession session) {
        Integer uid = getUidFromSession(session);
        String username = getUsernameFromSession(session);
        userService.changePassword(uid, username,
                oldPassword, newPassword);
        return new JsonResult<>(OK);
    }
```

## 3.4 修改密码：前端

在UserController中写完之后，只能通过地址栏手动编写url执行修改操作。为了能转移到前端完成修改，需要找到password.html中添加ajax请求的处理。

```js
<script type="text/javascript">
			//启动对btn-login按钮的监听
			$("#btn-change-password").click(function () {
				$.ajax({
					url: "/users/change_password",
					type: "POST",
					//表单数据的序列化。data后跟的是表单名
					data: $("#form-change-password").serialize(),
					dataType: "JSON",
					success: function (json) {
						if (json.state == 200) {
							alert("密码修改成功！");
						} else if (json.state == 5002) {
							alert("原密码错误，请重新输入！");
						} else {
							alert("密码修改失败！");
							}
					},
					error: function (xhr) {
						alert("密码修改时产生未知的异常。错误信息：" + xhr.message);
					}
				});
			});
		</script>
```

# 4 个人资料

## 4.1 个人资料：持久层

### 4.1.1 规划SQL语句

1 根据用户信息更新数据的SQL语句

```sql
update t_user set phone=? , email = ?, modified_user=?, modified_time=? where uid=?
```

2 根据uid，查询用户的数据。

```sql
select * from t_user where uid=?
```

查询用户的数据不需要再重复开发了（已经有了）

鉴于session有生命周期，在切换到修改个人资料页面时？

### 4.1.2 设计接口与抽象方法

更新用户的信息：方法的定义（在UserMapper.java里面定义抽象的业务）

### 4.1.3 sql映射的配置

```sql
<update id="updateInfoByUid">
        UPDATE t_user SET
        <!--if是条件判断标签，test属性接收的是一个返回值为boolean类型的条件。
            如果test的条件结果为真，则if标签内的语句执行-->
        <if test="phone!=null">phone=#{phone},</if>
        <if test="email!=null">email=#{email},</if>
        <if test="gender!=null">gender=#{},</if> 
        modified_user=#{},
        modified_time=#{}
        WHERE uid=#{uid}
    </update>
```

### 4.1.4 单元功能测试

（代码省略）

## 4.2 个人资料：业务层

### 4.2.1 规划异常

1 设计功能

    功能1 打开页面时，获取信息并于默认文本框中设置默认值。

    功能2 检测用户是否点击了修改按钮，如果检测到则执行修改用户信息的操作。

2 打开页面的时候，找不到用户的数据

3 打开页面后，用户数据虽然找到并显示了，但因为过长时间没操作，不能确定数据是否还存在。在点击删除按钮之前，还需要再次检测用户数据是否存在。

### 4.2.2 设计接口和抽象方法

两个功能模块，对应两个抽象方法的设计。

```java
    /**
     * 根据用户的id查询用户某些数据
     * @param uid 用户id
     * @return 用户的数据
     */
    User getByUid(Integer uid);

    /**
     * 更新用户的数据
     * @param uid 用户的id
     * @param username 用户的名称
     * @param user 用户对象的数据
     */
    void changeInfo(Integer uid, String username,
                    User user);
```

### 4.2.3 实现抽象方法

在UserServiceImpl中添加两个抽象方法的具体实现。

```java
    @Override
    // 控制层可以直接调用本层（业务层）的getByUid方法，获取smallUser的实例
    public User getByUid(Integer uid) {
        User result = userMapper.findByUid(uid);
        if (result == null  || result.getIsDelete()==1) {
            throw new UserNotFoundException("用户数据不存在");
        }
        User smallUser = new User(); //准备给前端设置默认值使用
        smallUser.setUsername(result.getUsername());
        smallUser.setPhone(result.getPhone());
        smallUser.setGender(result.getGender());

        return smallUser;
    }

    /**
     * 当前User对象中的数据只有三部分
     * （SpringBoot只注册表单中的值，
     * 表单中不存在的值uid和username需要被手动封装）
     */
    @Override
    public void changeInfo(Integer uid, String username, User user) {
        User result = userMapper.findByUid(uid);
        if (result == null  || result.getIsDelete()==1) {
            throw new UserNotFoundException("用户数据不存在");
        }
        user.setUid(uid);
        // 表单中已经存在，所以省略
        // user.setUsername(username);
        user.setModifiedUser(username);
        user.setModifiedTime(new Date());

        Integer rows = userMapper.updateInfoByUid(user);
        if (rows != 1) {
            throw new UpdateException("更新数据时产生未知的异常");
        }
    }
```

### 4.2.4 单元功能测试

（代码省略）

## 4.3 个人资料：控制层

### 4.3.1 处理异常

暂无新的异常

### 4.3.2 设计请求

1 设置一打开页面就发送当前用户数据的查询。

>     url: users/get_by_uid
> 
>     GET
> 
>     HttpSession session
> 
>     JsonResult<User>

2 点击修改按钮发送用户的数据修改操作请求的设计

>     users/change_info
> 
>     POST
> 
>     HttpSession session和User user
> 
>     JsonResult

### 4.3.2 处理请求

```java
@RequestMapping("get_by_uid")
    public JsonResult<User> getByUid(HttpSession session) {
        User data = userService.getByUid(getUidFromSession(session));
        return new JsonResult<>(OK, data);
    }
    // 在url中测试一下

    @RequestMapping("change_info")
    public JsonResult<Void> changeInfo(User user, HttpSession session) {
        // user对象有四部分数据：username、phone、email、gender
        // （html表单中有同名字段，则会自动注入）
        // uid还没有，需要从session里再次封装到user对象中。
        Integer uid = getUidFromSession(session);
        String username = getUsernameFromSession(session);
        userService.changeInfo(uid, username, user);
        return new JsonResult<>(OK);
    }
```

## 4.4 个人资料：前端

1 打开userdata.html页面，自动发送ajax请求，将查询到的数据填充到这个页面

2 在检测到用户点击“修改”按钮后，也发送一个ajax请求，修改数据。

```js
<script type="text/javascript">
			/**
			 * 一旦检测到当前的页面被加载，就会触发ready方法
			 * $(document).ready(function(){
			 *     //业务代码
			 * };
			 */
			$(document).ready(function() {
				$.ajax({
					url: "/users/get_by_uid",
					type: "GET",
					data: $("#form-change-info").serialize(),
					dataType: "json",
					success: function (json) {
						if (json.state == 200) {
							console.log("User Phone:", json.data.phone); // 检查 phone 是否存在
							//alert("注册成功！");
							// 将查询到的数据重新设置到控件中
							// val()用于给一个文本框控件赋值
							$("#username").val(json.data.username);
							$("#phone").val(json.data.phone);
							$("#email").val(json.data.email);
							// let radio = () 确定某个radio后，
							// radio = prop()方法，给某个元素添加属性+添加属性的值
							let radio = json.data.gender == 0 ?
									$("#gender-female") : $("#gender-male");
							radio.prop("checked", "checked");
						} else {
							alert("用户数据不存在！");
						}
					},
					error: function (xhr) {
						alert("查询用户信息时，产生了未知的错误！错误代码为 " + " " + xhr.status);
					}
				});
			});

			/**
			 * 触发修改
			 */
			$("#btn-change-info").click(function () {
				$.ajax({
					url: "/users/change_info",
					type: "POST",
					//表单数据的序列化。data后跟的是表单名
					data: $("#form-change-info").serialize(),
					dataType: "JSON",
					success: function (json) {
						if (json.state == 200) {
							alert("用户信息修改成功！");
							// 修改成功后，重新加载当前页面
							location.href = "./userdata.html";
						} else {
							alert("用户信息修改失败！");
						}
					},
					error: function (xhr) {
						alert("用户信息修改时产生未知的异常。错误信息：" + xhr.message);
					}
				});
			});
		</script>
```

# 5 上传头像

## 5.1 上传头像：持久层

### 5.1.1 规划SQL语句

将对应的文件保存在操作系统上，然后再把这个文件的路径给记录下来。因为记录路径是非常简便的，将来如果要打开这个文件，可以依据这个路径去找到相应的文件。所以在数据库中，只需要保存这个文件的路径即可。

所有的静态资源（图片、文件、其他资源文件……）放在某台专用服务器上。

所以本质上，需要的是一个更新用户avatar字段的sql语句。

```sql
update t_user set avatar=?, modified_user=?, modified_time=? where uid=?
```

### 5.1.2 设计接口和抽象方法

UserMapper接口中，定义一个抽象的方法。

```java
/**
     * 根据用户的uid值，修改用户的头像
     * //@Param注解：需要传递一个参数，是sql映射文件中#{}内部的占位符的变量名。
     * 当sql语句的占位符和映射的接口方法参数名不一致时，需要将某个参数强制注入到相应占位符变量中时可以使用。
     * @param uid
     * @param avatar
     * @param modifiedUser
     * @param modifiedTime
     * @return
     */
    Integer updateAvatarByUid(@Param("uid") Integer uid, //代表后面的uid的值要注入到前面占位符uid中去
                              @Param("avatar") String avatar,
                              @Param("modifiedUser") String modifiedUser,
                              @Param("modifiedTime") Date modifiedTime);
```

### 5.1.3 sql映射的配置

```sql
<update id="updateAvatarByUid">
        UPDATE t_user
        SET
            avatar=#{avatar},
            modified_user=#{modifiedUser},
            modified_time=#{modifiedTime}
        WHERE
            uid=#{uid}
    </update>
```

测试

## 5.2 上传头像：业务层

### 5.2.1 规划异常

1 各种情况导致用户的数据不存在（找不到对应的用户的数据）。

2 更新时，有可能会有各种未知的异常产生。

（UserNotFoundException、UpdateException都开发过了，无需重复开发）

### 5.2.2 设计接口与抽象方法

```java
    /**
     * 修改用户的头像
     * @param uid 用户id
     * @param avatar 用户头像的路径
     * @param username 用户的名称
     */
    void changeAvatar(Integer uid, String avatar,
                      String username);
```

### 5.2.3 实现抽象方法

```java
    @Override
    public void changeAvatar(Integer uid, String avatar, String username) {
        // 检测用户数据是否存在
        User result = userMapper.findByUid(uid);
        if (result == null || result.getIsDelete() == 1) {
            throw new UserNotFoundException("用户数据不存在");
        }
        Integer rows = userMapper.updateAvatarByUid(uid, avatar,
                        username, new Date());
        if (rows != 1) {
            throw new UpdateException("更新头像时产生未知的异常");
        }
    }
```

### 5.2.4 测试

## 5.3 上传头像：控制层

### 5.3.1 规划异常

> 文件异常父类的构建
> 
> FileUploadException 泛指文件上传的异常（父类，继承RuntimeException）
> 
> FileEmptyException 文件为空的异常
> 
> FileSizeException 文件大小超限
> 
> FileTypeException 文件类型异常
> 
> FileUploadIOException 文件读写异常
> 
> FileStateException 文件状态异常（例如先打开了文件，被占用了）
> 
> 对所有子类，五个构造方法显式声明，再继承相关的父类即可

### 5.3.2 处理异常

在BaseController里面给编码

```java
  else if (e instanceof FileEmptyException) {
              result.setState(6000);
              result.setMessage("");
        } else if (e instanceof FileSizeException) {
            result.setState(6001);
            result.setMessage("");
        } else if (e instanceof FileTypeException) {
            result.setState(6002);
            result.setMessage("");
        } else if (e instanceof FileStateException) {
            result.setState(6003);
            result.setMessage("");
        } else if (e instanceof FileUploadIOException) {
            result.setState(6004);
            result.setMessage("");
        }
```

注意@Exceptionhandler注解后面需要补充新的基类FileUploadException

### 5.3.3 设计请求

> url: users/change_avatar
> 
> POST（GET请求提交数据在2KB左右还行，太大就不行了）
> 
> HttpSession, MultipartFile file
> 
> JsonResult<String>（每次切换到上传头像页后一定拿到头像路径

### 5.3.4 处理请求

注意！html内相应控件标签的名字（name）和控制层UserController内方法传入参数的名字要一致，才能注入。否则，控制层参数前需要声明@RequestParam("前端名称")的强制符

```java
    // 文件大小限制：单位是字节，10M = 10*1024*1024
    public static final int AVATAR_MAX_SIZE = 10*1024*1024;
    // 文件类型限制：定义一个
    public static final List<String> AVATAR_TYPE = new ArrayList<>();
    static { // 静态块用于给List添加数据（或赋值）
        AVATAR_TYPE.add("image/jpeg"); //包含了jpg
        AVATAR_TYPE.add("image/png");
        AVATAR_TYPE.add("image/bmp");
        AVATAR_TYPE.add("image/gif");
    }
    
    @RequestMapping("change_avatar")
    public JsonResult<String> changeAvatar(HttpSession session,
                                           @RequestParam("file") MultipartFile file) {
        // 在这个方法内排除一系列异常
        // 方法外定义常量：文件大小上限、文件类型限制

        // 判断文件是否为空
        if (file.isEmpty()) {
            throw new FileEmptyException("文件为空");
        }
        // 判断文件大小
        if (file.getSize() > AVATAR_MAX_SIZE) {
            throw new FileSizeException("文件大小超出限制");
        }
        // 判断文件类型是否符合要求
        String contentType = file.getContentType();
        // 如果集合包含某个元素
        if (! AVATAR_TYPE.contains(contentType)) {
            throw new FileTypeException("文件类型不支持上传");
        }

        // 上传的文件，目录结构是.../upload/文件.jpg
        String parent = session.getServletContext()
                        .getRealPath("upload");
        // File对象指向这个路径，File是否存在
        File dir = new File(parent);
        if (!dir.exists()) {
            dir.mkdirs(); // 不存在就创建一个新的目录
            System.out.println(parent); //用于测试整个项目
        }
        // 为了杜绝直接覆盖，需要获取这个文件名称：UUID工具类生成一个新的字符串，作为文件名
        String originalFilename = file.getOriginalFilename();
        // 例如：avatar01.png（原名带后缀）
        System.out.println("originalFilename: " + originalFilename);
        // 获取字符串中最后一个小数点的位置
        int index = 0;
        try {
            index = originalFilename.lastIndexOf(".");
        } catch (FileUploadException e) {
            throw new FileTypeException("文件无扩展名！");
        }
        // 截取文件扩展名
        String suffix = originalFilename.substring(index);
        // 生成一个文件名并拼接扩展名
        String filename =
                UUID.randomUUID().toString().toUpperCase()
                + suffix;
        // 创建一个当前的名字的空文件
        File dest = new File(dir, filename);
        // 将参数file中的数据写入空文件中
        try {
            file.transferTo(dest); // 把file内的数据写入到了后缀相同的目标文件dest中
        } catch (FileStateException e) {
            throw new FileStateException("文件状态异常！");
        } catch (IOException e) {
            throw new FileUploadIOException("文件读写异常！");
        }

        Integer uid = getUidFromSession(session);
        String username = getUsernameFromSession(session);
        // 返回头像的路径 /upload/test.png
        String avatar = "/upload/" + filename;
        userService.changeAvatar(uid, avatar, username);

        // 返回头像的路径给前端页面，将来用于头像的展示使用
        return new JsonResult<>(OK, avatar);
    }
```

因为需要上传File，所以不能在地址栏测试，跳过。

## 5.4 上传头像：前端

在upload.html页面中，编写上传头像。

需要在html的相应表单中添加一些属性。

上传部分（不是前端返回响应部分）不需构建string标签了。

> 说明：如果直接使用表单直接进行文件的上传，需要给表单显式地添加一个属性enctype="multupart/form-data"，这样不会将目标文件的数据结构作修改再上传，这是不同于字符串的。

<!--上传头像表单开始-->

```html
<form action="/users/change_avatar"  
      method="post"  
      enctype="multipart/form-data"  
      class="form-horizontal" role="form">
```

注意！上面这段因为表单不能实现交互，需要在后续改写（删除这段）。

## 5.5 解决前端页面的bug

### 5.5.1 更改默认的大小限制

SpringMVC默认为1MB的文件可以进行上传。之前写的那个限额是在底层大小不限的前提下才能生效，默认不生效。

需要手动修改SpringMVC默认上传文件的大小。

修改方式1：直接在application.property配置文件中修改。

```
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=15MB
```

修改方式2：需要采用java代码的形式来设置文件上传大小的限制。在StoreApplication主类（最早加载）中进行配置。可以定义一个方法，必须使用@Bean（表示返回值是Bean类型）修饰符来修饰，名字随意。在类的前面添加一个@Configuration注解进行修饰类。要求返回值必须为MultipartConfigElement类型。

### 5.5.2 把运行后传回来的头像（路径）设置到前端

必须把表单提交改成script提交。

在页面中通过ajax请求来提交文件，提交完成后返回了一个json的串，从串中解析出data属性的数据，并设置到img头像标签的src属性内。

serialize()：可以将表单中的数据自动拼接成key=value的结构进行提交给服务器，一般提交的是普通的控件类型（text、password、radio、checkbox……）中的数据。

FormData类：文件不是普通的类型，而是FormData类（js中的），将表单中的数据保持原有的结构进行数据的提交。new FormData($("#form")[0])，参数是元素的整体值。FormData对象能存储文件类型的数据。

ajax默认处理数据是按照字符串的形式进行处理，并默认采用字符串的形式提交数据。因此，需要关闭这两个默认的设定。

【后续有必要修改的细节】

1. 控制层异常捕获基类内部，错误的细化

2. 头像保存位置的静态化：在 Spring Boot 项目中，创建一个配置类，例如 `WebMvcConfig`

3. 头像显示尺寸的统一化

### 5.3 登录后显示现有头像

（当然也可以利用$(document).ready(function()发送一个ajax请求，从数据库中读取头像路径并加以显示）

使用cookie保存头像（只要不清理就没事）

可以在更新头像成功后，将服务器返回的头像路径保存在客户端cookie对象中，然后每次检测到用户打开上传头像页面，在这个页面中，通过ready()方法来自动检测，去读取cookie中的头像，并设置到src属性上。

1 设置cookie中的值

第一步：在登录页面login.html中，导入cookie.js文件（检查一下upload里面有没有，没有也复制一份）

```html
<script src="../bootstrap3/js/jquery.cookie.js" type="text/javascript" charset="utf-8"></script>
```

第二步：导入cookie方法。key是cookie的名字，time需要取{expires:数字}的格式导入。

```js
$.cookie(key, value, time); //time是存活时间，的单位为天
```

2 在upload.html（头像更新）页面补充上cookie.js。

3 在upload.html页面通过ready()函数，自动读取cookie中的数据。

```html
<!--读取cookie中的头像-->
		<script type="text/javascript">
			$(document).ready(function () {
				// 声明一个avatar变量，给cookie的值找个地方放下
				let avatar = $.cookie("avatar");
				//console.log(avatar);
				// 将cookie中的值设置到头像的src属性上。
				$("#img-avatar").attr("src", avatar);
			});
		</script>
```

> 注意！由于这种方法需要先行登录→上传头像才能将头像放在cookie中，显然在不进行上传头像操作的时候，是无法正确读取当前头像的。所以后续有修改的必要，一是将头像保存在静态文件夹（而非每次运行tomcat自动生成的缓存文件夹），二是将userdata.html的$document方法修改为借助控制层的get_by_uid方法，从数据库中获取当前用户对应的头像地址并加以显示。至于修改后的显示，也类似改正。
> 
> 【已修改】二已经改掉了，只剩头像的静态保存化。但是实际工程中肯定也是存服务器，所以先不做了。

注意！取反操作符 ! 的优先级高于比较，所以需要把被取反的对象先括起来，再在前面取反，或者直接是某个值!=另一个值。

# 6 新增收货地址

## 6.0 数据表的创建



## 6.3 新增收货地址：持久层

### 6.3.1 各功能开发顺序

当前收货地址功能模块：列表的展示、修改、删除、设置默认、新增收货地址。

开发的顺序：新增收货地址→作列表的展示→设置默认收货地址→删除收货地址→修改收货地址

## 6.4 新增收货地址：业务层



## 6.5 新增收货地址：控制层



## 6.6 新增收货地址
